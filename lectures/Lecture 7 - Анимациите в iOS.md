# Анимациите в iOS
Анимациите са неразделна част от потребителският интерфейс и UX-а на приложенията. Анимацията е илюзия за движение или трансформация чрез показване на серия от изображения в бърза последователност, като всяко изображение се различава малко от предходното. Въпреки че анимацията подобрява практическата работа на потребителите, тя далеч не е просто храна за очите. Анимациите дават на потребителите обратна връзка или контекст за това, което се случва в потребителския интерфейс. Например често се случва при докосване на бутон или клетка от таблица, новият екран да се плъзне от дясно наляво, тези анимации визуално укрепват връзката между избрания елемент и представянето му. iOS, tvOS и OS X автоматично поддържат много от анимациите, които виждате, но можете също така да създавате и собствени анимации за потребителския интерфейс на приложението Ви.

### Core Animation
Core Animation е основата на анимациите в потребителският интерфейс. Core Animation е бърз 2D layering engine, който съдържа Objective-C и Swift интерфейс за достъп до него. След като създадете core анимация изпълнението й е напълно автоматично. Не е нужно да създавате цикъл или таймер, не е нужно на изрисувате анимацията кадър по кадър.

Основната технология, използвана в Core Animation са layer-ите. Това са леки обекти от тип `CALayer`, които макар и подобни на view-тата, всъщност са моделни обекти добавени във всяко view. Те капсулират геометрията, времето и визуалните свойства на view-то, който показва съдържание въз основа на тези фактори. Всичко, което трябва да направите, е да настроите съдържанието на layer-a, да конфигурирате свойствата на анимацията и след това оставете Core Animation да си свърши работата.

Всяка анимация трябва да има цел, тип и време за изпълнение. Целта е видим обект с property, което може да бъде анимирано *(например неговият frame)*. Трябва също така да посочите какъв тип анимация да изпълните - например дали да преместите обекта, да го преоразмерите, да го направите плавно видим или невидим. И накрая, всяка анимация изисква информация за времето, което включва няколко фактора: продължителност на анимацията, кога ще започне, дали се повратя, нейната крива на изпълнение *(например дали започва бавно, а в края си се забързва)*.

#### Използване:

Създаване обект от тип `CABasicAnimation`. Като `keyPath` е property-то na layer-a, което ще променяме по време на анимацията. Можете да изберете желаното property, като напишете името му в String формат:

```
let animation = CABasicAnimation(keyPath: "opacity")
``` 
или използвате #keyPath(), като изпишете типа на обекта, в случая `CALayer`, и неговото property, което искате да достъпите:

```
let animation = CABasicAnimation(keyPath: #keyPath(CALayer.opacity))
```

За да зададете времетраенето на анимацията използваме property-то `duration`:

`animation.duration = 0.3`

Следващата стъпка е да зададем начална и крайна стойност на property-то:

`animation.fromValue = 0` - Начална стойност, която ще бъде зададена при стартиране на анимацията.

`animation.toValue = 1` - Крайна стойност, към която ще се предвижваме до края на анимацията.

Можете да зададете колко пъти да бъде повторена анимацията чрез `repeatCount`, което може да бъде от 0 - няма да бъде повторена, което е зададено по подразбиране ; до `Float.infinity`, което ще повтаря анимацията завинаги.

Също така и кога да започне чрез `beginTime`. Задайте стойноста, използвайки `CACurrentMediaTime()` и добавите към него желаните секунди след които да започне анимацията. Например: `animation.beginTime = CACurrentMediaTime() + 0.3`.

Остава единствено да добавим анимацията към нашият layer.

`someView.layer.add(animation, forKey: "fadeIn")`

Като `key` параметърът, който подаваме, е уникален за анимациите на layer-а ключ, който ще ни помогне да различим дадена анимация от останалите. Също така можем да направим група от анимации, които да добавим към layer.

```
let animationGroup = CAAnimationGroup()
	animationGroup.animations = [animationOne, animationTwo]
animationGroup.repeatCount = .infinity
animationGroup.duration = animationOne.duration + animationTwo.duration
someView.layer.add(animation, forKey: "fade")
```

### UIView анимации

След като разгледахме основата на анимациите е време да разгледаме и UIView анимациите, с които се работи много по-лесно. Всяка UIView анимация използва Core анимация за изпълнението си, но предлага лесен за работа интерфейс.

UIView анимациите могат да бъдат създадени чрез следните клас методи на UIView:

* `animate(withDuration duration: TimeInterval, delay: TimeInterval, options: UIView.AnimationOptions = [], animations: @escaping () -> Void, completion: ((Bool) -> Void)? = nil)`
	* `duration` - колко време ще продължи анимацията;
	* `delay` - селд колко секунди ще започне анимацията спрямо текущото време;
	* `options` - опции при изпълнение на анимацията. Можете да видите пълният им списък [тук](https://developer.apple.com/documentation/uikit/uiview/animationoptions)
	* `animations` - блок от промените по property-тата на view-та, които ще настъпят по време на анимацията. Тук можете да промените позицията, размера, цвета, прозрачността, да промените техният `transform` параметър (това позволява, скалиране, преместване и ротация) и други;
	* `completion` блок от код, който можете да изпълните при приключване на анимацията.
* `animate(withDuration duration: TimeInterval, delay: TimeInterval, usingSpringWithDamping dampingRatio: CGFloat, initialSpringVelocity velocity: CGFloat, options: UIView.AnimationOptions = [], animations: @escaping () -> Void, completion: ((Bool) -> Void)? = nil)`
	* `dampingRatio` - Можете да зададете стойност различна 1 за да направите завършъка на анимацията подобно на пружина, като този ефект ще бъде засилен, колкото по-близо стойноста се доближава до нулата; 
	* `velocity` - Началната скорост при започване на анимацията. Тази стойност представлява цялото преместване в анимацията за 1 секунда. Може да бъде стойност от 0 до 1. Например ако цялото преместване в анимацията е равно на 200 пиксела, а вие искате началната скорост да е 100 пиксела в секунда ще трябва да зададете стойност `0.5`.

#### Пример:
```
UIView.animate(withDuration: 0.2, delay: 0, options: [.repeat], animations: {
	someView.alpha = 0
}) { _ in
	UIView.animate(withDuration: 0.3, animations: {
		someView.alpha = 1
	})
}
```
Задаваме анимация, която ще продължи 0,2 секунди и ще накара алфа каналът на `someView` да достигне 0, което ще накара view-то да изчезне. Когато тази анимация приключи, задаваме нова, която ще продължи 0,3 секунди и ще направи `someView` отново видимо. Забележете че в `options` сме задали параметър `.repeat`, което ще накара комбинацията от анимации да се повтаря завинаги.

### UIView transitions

Понякога се налага да заменим едно view с друго или да заменим цялото съдържание на някое view. За тази цел Apple ни предоставят UIView transitions.

* `UIView.transition(from:, to:, duration:, options:, completion:)`
	* `from` - view-то, което ще заменим, имайте предвид че премахването на вюто от неговото superview ще стане автоматично;
	* `to` - view-то, което ще заеме мястото на предходното. Отново този метод ще се погрижи за добавянето на новото view на мястото на предходното;
	* `options` - тук можем да зададем някои опции на анимацията, но също така можем да зададем вида на анимацията, чрез следните опции: 
		* .transitionFlipFromLeft;
		* .transitionFlipFromRight;
		* .transitionCurlUp;
		* .transitionCurlDown;
		* .transitionCrossDissolve;
		* .transitionFlipFromTop;
		* .transitionFlipFromBottom.
* `UIView.transition(with:, duration:, options:, animations:, completion:)`
	* `with` - view-то което ще променяме;
	* `options` - можем да използваме същите опции, както в предният клас метод;
	* `animations` - тук задаваме промените, които ще настъпят в края на анимацията.
